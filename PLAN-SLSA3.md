# SLSA Level 3 Compliance Plan for Verity

## Current State Assessment

### What's already in place (meets SLSA requirements)
- **Version-controlled source** — Git on GitHub
- **Hosted build platform** — GitHub Actions with ephemeral runners (SLSA L3 build isolation)
- **Scripted, automated builds** — No manual build steps
- **Dependency pinning** — go.sum hashes, GitHub Actions pinned by SHA, Helm chart versions pinned
- **Vulnerability scanning** — Trivy + Copa, daily scheduled scans
- **Automated dependency updates** — Renovate with automerge for security patches
- **`id-token: write`** — Already present in `publish.yaml` (needed for keyless signing)

### What's missing (gaps for SLSA L3 + max compliance)
1. **No artifact signing** — Patched container images and Helm charts are pushed unsigned
2. **No SLSA provenance** — No build provenance attestation generated for any artifact
3. **No SBOM generation** — No Software Bill of Materials for container images
4. **No transparency log** — No signatures recorded in Rekor
5. **No verification tooling** — No way for consumers to verify artifact authenticity

## Artifacts to Protect

| Artifact | Where produced | Where published |
|---|---|---|
| Patched container images | `patch` job in `patch-matrix.yaml` and `scheduled-scan.yaml` | `ghcr.io/<org>/<image>:<tag>-patched` |
| Helm chart OCI packages | `publish` job in `publish.yaml` via `publish-charts.sh` | `oci://ghcr.io/<org>/charts/<name>:<version>` |

## Implementation Plan

### 1. Sign patched container images with cosign (keyless)

**Files modified:** `patch-matrix.yaml`, `scheduled-scan.yaml`

After each patched image is pushed, sign it using cosign with keyless OIDC (Sigstore/Fulcio). This records signatures in the Rekor transparency log automatically.

Changes to the `patch` job:
- Add `id-token: write` permission (needed for keyless signing)
- Add step: install cosign via `sigstore/cosign-installer`
- Add step: get pushed image digest via `crane digest`
- Add step: `cosign sign` the image by digest (keyless, `--yes` flag)

### 2. Attest build provenance for container images (SLSA L3)

**Files modified:** `patch-matrix.yaml`, `scheduled-scan.yaml`

Use GitHub's native `actions/attest-build-provenance` to generate SLSA provenance attestations. This is the official path to SLSA L3 on GitHub Actions — provenance is generated by the platform itself, not user code.

Changes to the `patch` job:
- Add `attestations: write` permission
- Add step: `actions/attest-build-provenance` with the pushed image digest as subject

### 3. Generate and attest SBOMs for container images

**Files modified:** `patch-matrix.yaml`, `scheduled-scan.yaml`

Trivy is already installed in the patch job. Use it to generate a CycloneDX SBOM, then attest it.

Changes to the `patch` job:
- Add step: `trivy image --format cyclonedx` to generate SBOM JSON
- Add step: `actions/attest-sbom` to attest the SBOM against the image digest

### 4. Sign Helm chart OCI artifacts with cosign

**Files modified:** `publish.yaml`, `publish-charts.sh`

After each Helm chart is pushed to the OCI registry, sign it.

Changes:
- `publish-charts.sh`: After `helm push`, capture the chart digest and output it
- `publish.yaml`: Add cosign install step, add signing step that reads digests from the script and signs each chart
- Add `attestations: write` permission

### 5. Attest build provenance for Helm charts

**Files modified:** `publish.yaml`

Use `actions/attest-build-provenance` for the published Helm charts.

### 6. Add verification script for consumers

**Files added:** `.github/scripts/verify-artifacts.sh`

A script consumers can use to verify cosign signatures and attestations on both images and charts. Documents the verification commands.

## Detailed Workflow Changes

### `patch-matrix.yaml` — patch job additions

```yaml
permissions:
  contents: write
  packages: write
  pull-requests: read
  id-token: write        # NEW — keyless cosign signing
  attestations: write    # NEW — GitHub artifact attestation
```

New steps after "Patch image":

```yaml
- name: Install cosign
  uses: sigstore/cosign-installer@v3

- name: Get image digest
  id: digest
  run: |
    # Read the result JSON to get the patched image ref
    result_file=$(ls .verity/results/*.json | head -1)
    registry=$(jq -r '.patched_registry' "$result_file")
    repo=$(jq -r '.patched_repository' "$result_file")
    tag=$(jq -r '.patched_tag' "$result_file")
    if [ "$registry" != "null" ] && [ -n "$registry" ]; then
      image="${registry}/${repo}:${tag}"
      digest=$(crane digest "$image")
      echo "image=${registry}/${repo}@${digest}" >> "$GITHUB_OUTPUT"
      echo "image_with_tag=${image}" >> "$GITHUB_OUTPUT"
      echo "has_image=true" >> "$GITHUB_OUTPUT"
    else
      echo "has_image=false" >> "$GITHUB_OUTPUT"
    fi

- name: Sign image with cosign
  if: steps.digest.outputs.has_image == 'true'
  run: cosign sign --yes "${{ steps.digest.outputs.image }}"

- name: Attest build provenance
  if: steps.digest.outputs.has_image == 'true'
  uses: actions/attest-build-provenance@v2
  with:
    subject-name: # registry/repo from result
    subject-digest: # digest from crane

- name: Generate SBOM
  if: steps.digest.outputs.has_image == 'true'
  run: |
    trivy image --format cyclonedx --output .verity/sbom.cdx.json \
      "${{ steps.digest.outputs.image_with_tag }}"

- name: Attest SBOM
  if: steps.digest.outputs.has_image == 'true'
  uses: actions/attest-sbom@v2
  with:
    subject-name: # registry/repo from result
    subject-digest: # digest from crane
    sbom-path: .verity/sbom.cdx.json
```

### `publish.yaml` — chart signing additions

```yaml
permissions:
  contents: read
  packages: write
  pages: write
  id-token: write        # already present
  attestations: write    # NEW
```

New steps after "Publish wrapper charts":

```yaml
- name: Install cosign
  uses: sigstore/cosign-installer@v3

- name: Sign published charts
  run: ./.github/scripts/sign-charts.sh . ghcr.io ${{ github.repository_owner }}
```

### `publish-charts.sh` modifications

After `helm push`, capture and output the OCI digest for each chart so the signing step can use it.

### New script: `sign-charts.sh`

Iterates over charts, resolves each OCI digest, runs `cosign sign --yes` on each.

## Permission Summary

| Workflow | Current permissions | Added |
|---|---|---|
| `patch-matrix.yaml` | contents:write, packages:write, pull-requests:read | **id-token:write**, **attestations:write** |
| `scheduled-scan.yaml` | contents:write, pull-requests:write, packages:write | **id-token:write**, **attestations:write** |
| `publish.yaml` | contents:read, packages:write, pages:write, id-token:write | **attestations:write** |

## What This Achieves

| SLSA L3 Requirement | How it's met |
|---|---|
| Provenance exists | `actions/attest-build-provenance` generates SLSA v1.0 provenance |
| Hosted build platform | GitHub Actions (already met) |
| Hardened builds | GitHub-hosted runners + platform-generated provenance (can't be falsified by build tenant) |
| Artifact signing | Cosign keyless signing via Fulcio OIDC + Rekor transparency log |
| SBOM | CycloneDX SBOM generated by Trivy, attested via `actions/attest-sbom` |
| Verification | `gh attestation verify` + `cosign verify` for consumers |

## No changes needed to Go code
All changes are in GitHub Actions workflows and shell scripts. The verity Go binary, its build process, and its functionality remain unchanged.
